// Fichier qui se connecte à la DB et transforme les modèles en tables.
// Prisma s'en sert pour créer les tables ou les modifier.

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Workout {
  id         String    @id @default(cuid())
  title      String
  note       String?
  finishedAt DateTime?

  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  items     WorkoutItem[]

  // back-relation vers PlanningJour
  PlanningJour PlanningJour[]
}

model Planning {
  id    String         @id @default(cuid())
  nom   String
  debut DateTime
  fin   DateTime
  jours PlanningJour[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum PlanningJourStatus {
  PLANNED
  DONE
}

model PlanningJour {
  id   String   @id @default(cuid())
  date DateTime
  note String?

  // relations
  planning   Planning @relation(fields: [planningId], references: [id], onDelete: Cascade)
  planningId String

  workout   Workout @relation(fields: [workoutId], references: [id], onDelete: Restrict)
  workoutId String

  // suivi d'exécution
  status PlanningJourStatus @default(PLANNED)
  doneAt DateTime?

  // empêcher le même Workout 2x le même jour dans un même planning
  @@unique([planningId, date, workoutId])
  // index pour requêtes rapides par jour
  @@index([planningId, date])
}

model Utilisateur {
  id         String   @id @default(cuid())
  email      String   @unique
  password   String
  firstName  String
  lastName   String
  mfaEnabled Boolean  @default(false)
  mfaSecret  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  refreshTokens RefreshToken[]
  MfaChallenge  MfaChallenge[]
}

model RefreshToken {
  id            String    @id @default(cuid())
  utilisateurId String
  tokenHash     String
  jti           String    @unique //Jeton d'identifiant unique du token
  expiresAt     DateTime //Date d'expiration du token
  revoked       Boolean   @default(false)
  createdAt     DateTime  @default(now())
  revokedAt     DateTime?

  utilisateur Utilisateur @relation(fields: [utilisateurId], references: [id])

  @@index([utilisateurId, revoked])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

/// Challenge MFA "code à 6 chiffre" envoyé à l'utilisateur (mail/SMS)
model MfaChallenge {
  id String @id @default(cuid())

  ///L'utilisateur concerné (relation obligatoire)
  utilisateurId String
  utilisateur   Utilisateur @relation(fields: [utilisateurId], references: [id], onDelete: Cascade)

  /// Liaison temporaire entre /auth/login (MFA requis) et /auth/mfa/verify
  /// Sert de "ticket" court, indépendant de l'ID utilisateur.
  tempSessionId String @unique

  /// Code à 6 chiffres (ex: “123456”). On peut le stocker en clair côté dev ;
  /// en prod, tu peux hasher si tu veux pousser la sécurité (coût supplémentaire).
  code String

  /// Validité du challenge (ex: now + 300s)
  expiresAt DateTime

  /// Indique si le challenge a été consommé (évite les replays)
  used Boolean @default(false)

  createdAt DateTime @default(now())

  /// Index pour retrouver vite les challenges d’un utilisateur
  @@index([utilisateurId])
  /// Index pour nettoyer (cron) les challenges expirés
  @@index([expiresAt])
}

model Exercise {
  id              String   @id @default(cuid())
  slug            String   @unique
  name            String
  primaryMuscle   String
  secondaryMuscle String?
  equipment       String?
  level           String?
  instructions    String?
  mediaUrl        String?
  source          String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  items WorkoutItem[]

  @@index([primaryMuscle])
  @@index([equipment])
}

model WorkoutItem {
  id         String @id @default(cuid())
  order      Int
  workoutId  String
  exerciseId String

  workout  Workout      @relation(fields: [workoutId], references: [id], onDelete: Cascade)
  exercise Exercise     @relation(fields: [exerciseId], references: [id], onDelete: Restrict)
  sets     WorkoutSet[]

  @@unique([workoutId, order])
  @@index([exerciseId])
}

model WorkoutSet {
  id     String @id @default(cuid())
  reps   Int
  weight Float?
  rest   Int?
  rpe    Float?

  workoutItemId String
  item          WorkoutItem @relation(fields: [workoutItemId], references: [id], onDelete: Cascade)

  @@index([workoutItemId])
}
